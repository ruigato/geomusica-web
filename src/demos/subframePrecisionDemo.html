<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Subframe Precision Triggering Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            background-color: #333;
            color: white;
            padding: 20px;
            border-radius: 5px;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
            background-color: #eee;
            padding: 20px;
            border-radius: 5px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .visualizer {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .visualization {
            flex: 1;
            min-width: 500px;
            height: 400px;
            position: relative;
            background-color: #000;
            border-radius: 5px;
            overflow: hidden;
        }
        
        .visualization-title {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 3px;
        }
        
        .results {
            margin-top: 20px;
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }
        
        .result-box {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .result-title {
            font-weight: bold;
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        
        .result-content {
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        
        canvas {
            width: 100%;
            height: 100%;
        }
        
        button {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        select, input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .time-marker {
            position: absolute;
            width: 2px;
            height: 10px;
            background-color: #ff0000;
            pointer-events: none;
        }
        
        .precision-marker {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background-color: #ffff00;
            pointer-events: none;
        }
        
        .timeline {
            position: relative;
            height: 40px;
            background-color: #333;
            margin-top: 10px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Subframe Precision Triggering Demo</h1>
            <p>Visualize the enhanced temporal trigger system with high-precision subframe detection</p>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <h3>Test Configuration</h3>
                <div class="control-row">
                    <label for="frame-rate">Frame Rate (fps):</label>
                    <select id="frame-rate">
                        <option value="60">60 FPS</option>
                        <option value="30">30 FPS</option>
                        <option value="15">15 FPS</option>
                    </select>
                </div>
                <div class="control-row">
                    <label for="rotation-speed">Rotation Speed:</label>
                    <select id="rotation-speed">
                        <option value="1">1 rotation per second</option>
                        <option value="0.5">0.5 rotations per second</option>
                        <option value="2">2 rotations per second</option>
                    </select>
                </div>
                <div class="control-row">
                    <label for="test-duration">Duration (seconds):</label>
                    <input type="number" id="test-duration" min="1" max="10" value="3">
                </div>
                <div class="control-row checkbox-container">
                    <input type="checkbox" id="enable-frame-drops" checked>
                    <label for="enable-frame-drops">Simulate frame drops</label>
                </div>
            </div>
            
            <div class="control-group">
                <h3>Engine Configuration</h3>
                <div class="control-row">
                    <label for="micro-steps">Micro Steps:</label>
                    <input type="number" id="micro-steps" min="2" max="50" value="10">
                </div>
                <div class="control-row">
                    <label for="resolution">Temporal Resolution (Hz):</label>
                    <input type="number" id="resolution" min="100" max="10000" value="1000">
                </div>
                <div class="control-row checkbox-container">
                    <input type="checkbox" id="high-precision" checked>
                    <label for="high-precision">Use high precision algorithms</label>
                </div>
                <div class="control-row checkbox-container">
                    <input type="checkbox" id="track-velocity" checked>
                    <label for="track-velocity">Track velocity</label>
                </div>
            </div>
            
            <div class="control-group">
                <h3>Visualization</h3>
                <div class="control-row checkbox-container">
                    <input type="checkbox" id="show-crossing-points" checked>
                    <label for="show-crossing-points">Show crossing points</label>
                </div>
                <div class="control-row checkbox-container">
                    <input type="checkbox" id="show-path-sampling" checked>
                    <label for="show-path-sampling">Show path sampling</label>
                </div>
                <div class="control-row checkbox-container">
                    <input type="checkbox" id="show-interpolation" checked>
                    <label for="show-interpolation">Show interpolation</label>
                </div>
                <div class="control-row">
                    <button id="run-test">Run Test</button>
                </div>
                <div class="control-row">
                    <button id="run-comparison">Run Comparison</button>
                </div>
                <div class="control-row">
                    <button id="run-independence-test">Test Frame-Rate Independence</button>
                </div>
            </div>
        </div>
        
        <div class="visualizer">
            <div class="visualization">
                <div class="visualization-title">Subframe Precision Visualization</div>
                <canvas id="visualization-canvas"></canvas>
                <div class="timeline" id="timeline"></div>
            </div>
        </div>
        
        <div class="results">
            <div class="result-box">
                <div class="result-title">Test Results</div>
                <div class="result-content" id="test-results">
                    Run a test to see results.
                </div>
            </div>
            
            <div class="result-box">
                <div class="result-title">Precision Analysis</div>
                <div class="result-content" id="precision-analysis">
                    Run a test to see precision analysis.
                </div>
            </div>
            
            <div class="result-box">
                <div class="result-title">Frame Rate Comparison</div>
                <div class="result-content" id="framerate-comparison">
                    Run a comparison to see results across different frame rates.
                </div>
            </div>
            
            <div class="result-box">
                <div class="result-title">Frame-Rate Independence Test</div>
                <div class="result-content" id="framerate-independence">
                    Run the test to compare trigger consistency across different frame rates.
                </div>
            </div>
        </div>
    </div>
    
    <script type="module">
        import * as THREE from '../../node_modules/three/build/three.module.js';
        import { SubframePrecisionTest } from '../tests/subframePrecisionTest.js';
        import { TemporalTriggerEngine } from '../triggers/temporalTriggers.js';
        
        // Global variables
        let renderer, scene, camera;
        let testInstance;
        let animationFrameId = null;
        let runningTest = false;
        let testResults = [];
        let startTime = 0;
        let rotatingSquare, axisHelper;
        let crossingMarkers = [];
        let samplingPoints = [];
        
        // Initialize the visualization
        function initVisualization() {
            // Create Three.js scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            
            // Set up camera
            camera = new THREE.PerspectiveCamera(75, 1, 0.1, 100);
            camera.position.z = 5;
            
            // Create renderer
            const canvas = document.getElementById('visualization-canvas');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            
            // Add axis helper
            axisHelper = new THREE.Group();
            
            // Y-axis (green)
            const yAxisGeometry = new THREE.BufferGeometry();
            const yAxisVertices = new Float32Array([
                0, -3, 0,
                0, 3, 0
            ]);
            yAxisGeometry.setAttribute('position', new THREE.BufferAttribute(yAxisVertices, 3));
            const yAxisMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
            const yAxis = new THREE.Line(yAxisGeometry, yAxisMaterial);
            
            // X-axis (red)
            const xAxisGeometry = new THREE.BufferGeometry();
            const xAxisVertices = new Float32Array([
                -3, 0, 0,
                3, 0, 0
            ]);
            xAxisGeometry.setAttribute('position', new THREE.BufferAttribute(xAxisVertices, 3));
            const xAxisMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
            const xAxis = new THREE.Line(xAxisGeometry, xAxisMaterial);
            
            axisHelper.add(xAxis, yAxis);
            scene.add(axisHelper);
            
            // Create rotating square
            const squareGeometry = new THREE.BufferGeometry();
            const squareVertices = new Float32Array([
                1, 1, 0,
                1, -1, 0,
                -1, -1, 0,
                -1, 1, 0,
                1, 1, 0
            ]);
            squareGeometry.setAttribute('position', new THREE.BufferAttribute(squareVertices, 3));
            
            const squareMaterial = new THREE.LineBasicMaterial({ color: 0x2080ff });
            rotatingSquare = new THREE.Line(squareGeometry, squareMaterial);
            scene.add(rotatingSquare);
            
            // Add vertex points
            const pointGeometry = new THREE.SphereGeometry(0.05, 16, 16);
            const pointMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            for (let i = 0; i < 4; i++) {
                const point = new THREE.Mesh(pointGeometry, pointMaterial.clone());
                point.position.set(
                    squareVertices[i * 3],
                    squareVertices[i * 3 + 1],
                    0.1
                );
                rotatingSquare.add(point);
            }
            
            // Resize function
            function resizeRenderer() {
                const container = document.querySelector('.visualization');
                renderer.setSize(container.clientWidth, container.clientHeight);
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
            }
            
            // Call resize initially and on window resize
            resizeRenderer();
            window.addEventListener('resize', resizeRenderer);
            
            // Initialize test instance
            testInstance = new SubframePrecisionTest();
            
            // Start animation loop
            animate();
        }
        
        // Animation loop
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            
            // Only rotate if a test is running
            if (runningTest) {
                const currentTime = performance.now() / 1000;
                const elapsed = currentTime - startTime;
                
                // Get rotation speed
                const rotationSpeed = parseFloat(document.getElementById('rotation-speed').value);
                
                // Update rotation
                rotatingSquare.rotation.z = elapsed * rotationSpeed * Math.PI * 2;
            }
            
            // Render the scene
            renderer.render(scene, camera);
        }
        
        // Add a crossing marker
        function addCrossingMarker(x, y, z, timestamp, isPrecise = false) {
            const markerGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const markerMaterial = new THREE.MeshBasicMaterial({ 
                color: isPrecise ? 0xffff00 : 0xff0000,
                transparent: true,
                opacity: 0.7
            });
            
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.set(x, y, z);
            marker.userData.timestamp = timestamp;
            scene.add(marker);
            
            crossingMarkers.push(marker);
            
            // Add to timeline
            addTimelineMarker(timestamp);
            
            return marker;
        }
        
        // Add sampling points visualization
        function addSamplingPoint(x, y, z, timestamp, isMicroStep = false) {
            const pointGeometry = new THREE.SphereGeometry(isMicroStep ? 0.03 : 0.05, 8, 8);
            const pointMaterial = new THREE.MeshBasicMaterial({ 
                color: isMicroStep ? 0x00ffff : 0x00ff00,
                transparent: true,
                opacity: 0.5
            });
            
            const point = new THREE.Mesh(pointGeometry, pointMaterial);
            point.position.set(x, y, z);
            point.userData.timestamp = timestamp;
            scene.add(point);
            
            samplingPoints.push(point);
            
            return point;
        }
        
        // Add a marker to the timeline
        function addTimelineMarker(timestamp) {
            const timeline = document.getElementById('timeline');
            const timeMarker = document.createElement('div');
            timeMarker.className = 'time-marker';
            
            // Calculate position based on timestamp
            const testDuration = parseFloat(document.getElementById('test-duration').value);
            const normalizedPosition = (timestamp - startTime) / testDuration;
            const position = normalizedPosition * timeline.clientWidth;
            
            timeMarker.style.left = `${position}px`;
            timeMarker.style.top = '0';
            timeMarker.style.height = '100%';
            
            timeline.appendChild(timeMarker);
            
            // Add tooltip with timestamp
            timeMarker.title = `t=${timestamp.toFixed(6)}s`;
        }
        
        // Clear all markers
        function clearMarkers() {
            // Remove from scene
            crossingMarkers.forEach(marker => {
                scene.remove(marker);
            });
            
            samplingPoints.forEach(point => {
                scene.remove(point);
            });
            
            // Clear arrays
            crossingMarkers = [];
            samplingPoints = [];
            
            // Clear timeline
            const timeline = document.getElementById('timeline');
            timeline.innerHTML = '';
        }
        
        // Run a single test
        async function runTest() {
            // Clear previous results
            clearMarkers();
            
            // Get test parameters
            const fps = parseInt(document.getElementById('frame-rate').value);
            const rotationSpeed = parseFloat(document.getElementById('rotation-speed').value);
            const duration = parseFloat(document.getElementById('test-duration').value);
            const enableFrameDrops = document.getElementById('enable-frame-drops').checked;
            
            // Get engine configuration
            const microSteps = parseInt(document.getElementById('micro-steps').value);
            const resolution = parseInt(document.getElementById('resolution').value);
            const useHighPrecision = document.getElementById('high-precision').checked;
            const trackVelocity = document.getElementById('track-velocity').checked;
            
            // Update UI
            document.getElementById('test-results').textContent = 'Running test...';
            document.getElementById('precision-analysis').textContent = 'Running test...';
            
            // Create new test instance with configured parameters
            testInstance = new SubframePrecisionTest();
            testInstance.engine = new TemporalTriggerEngine({
                resolution,
                microSteps,
                useHighPrecision,
                trackVelocity,
                debugMode: true
            });
            
            // Start tracking time for visualization
            startTime = performance.now() / 1000;
            runningTest = true;
            
            // Run the test (asynchronously)
            let results;
            if (enableFrameDrops) {
                // Use setTimeout to let UI update first
                await new Promise(resolve => setTimeout(resolve, 100));
                results = testInstance.runFrameDropTest();
            } else {
                await new Promise(resolve => setTimeout(resolve, 100));
                results = testInstance.runFrameRateTest(fps, duration, rotationSpeed * Math.PI * 2);
            }
            
            // Store results
            testResults = results;
            
            // Stop the test
            runningTest = false;
            
            // Display results
            displayResults(results);
            
            // Visualize results if enabled
            if (document.getElementById('show-crossing-points').checked) {
                visualizeCrossings(results);
            }
        }
        
        // Run comparison test
        async function runComparison() {
            // Clear previous results
            clearMarkers();
            
            // Update UI
            document.getElementById('framerate-comparison').textContent = 'Running comparison...';
            
            // Get engine configuration
            const microSteps = parseInt(document.getElementById('micro-steps').value);
            const resolution = parseInt(document.getElementById('resolution').value);
            const useHighPrecision = document.getElementById('high-precision').checked;
            const trackVelocity = document.getElementById('track-velocity').checked;
            
            // Create new test instance with configured parameters
            testInstance = new SubframePrecisionTest();
            testInstance.engine = new TemporalTriggerEngine({
                resolution,
                microSteps,
                useHighPrecision,
                trackVelocity,
                debugMode: true
            });
            
            // Start tracking time for visualization
            startTime = performance.now() / 1000;
            runningTest = true;
            
            // Run the comparison (asynchronously)
            await new Promise(resolve => setTimeout(resolve, 100));
            const results = testInstance.runComparisonTest();
            
            // Stop the test
            runningTest = false;
            
            // Display comparison results
            displayComparisonResults(results);
        }
        
        // Display test results
        function displayResults(results) {
            if (!results || results.length === 0) {
                document.getElementById('test-results').textContent = 'No results detected.';
                document.getElementById('precision-analysis').textContent = 'No data available for analysis.';
                return;
            }
            
            // Create results text
            let resultsText = `Detected ${results.length} crossings:\n\n`;
            
            results.forEach((result, index) => {
                resultsText += `${index + 1}. Frame ${result.frame} - Time: ${result.crossingTime.toFixed(6)}s\n`;
                resultsText += `   Position: (${result.position.x.toFixed(3)}, ${result.position.y.toFixed(3)})\n`;
                resultsText += `   Subframe Precision: ${result.subframePrecision.toFixed(3)}ms\n\n`;
            });
            
            document.getElementById('test-results').textContent = resultsText;
            
            // Create precision analysis
            let analysisText = 'Precision Analysis:\n\n';
            
            // Calculate statistics
            const totalPrecision = results.reduce((sum, r) => sum + Math.abs(r.subframePrecision), 0);
            const avgPrecision = totalPrecision / results.length;
            
            // Find min and max precision
            const precisions = results.map(r => Math.abs(r.subframePrecision));
            const minPrecision = Math.min(...precisions);
            const maxPrecision = Math.max(...precisions);
            
            // Calculate standard deviation
            const variance = precisions.reduce((sum, p) => sum + Math.pow(p - avgPrecision, 2), 0) / precisions.length;
            const stdDev = Math.sqrt(variance);
            
            analysisText += `Total Crossings: ${results.length}\n`;
            analysisText += `Average Precision: ${avgPrecision.toFixed(3)}ms\n`;
            analysisText += `Min Precision: ${minPrecision.toFixed(3)}ms\n`;
            analysisText += `Max Precision: ${maxPrecision.toFixed(3)}ms\n`;
            analysisText += `Standard Deviation: ${stdDev.toFixed(3)}ms\n\n`;
            
            // Timing interval analysis
            if (results.length > 1) {
                const intervals = [];
                for (let i = 1; i < results.length; i++) {
                    intervals.push(results[i].crossingTime - results[i-1].crossingTime);
                }
                
                const avgInterval = intervals.reduce((sum, i) => sum + i, 0) / intervals.length;
                const expectedInterval = 1 / parseFloat(document.getElementById('rotation-speed').value);
                
                analysisText += `Average Time Between Crossings: ${avgInterval.toFixed(6)}s\n`;
                analysisText += `Expected Interval: ${expectedInterval.toFixed(6)}s\n`;
                analysisText += `Timing Accuracy: ${(100 * (1 - Math.abs(avgInterval - expectedInterval) / expectedInterval)).toFixed(2)}%\n`;
            }
            
            document.getElementById('precision-analysis').textContent = analysisText;
        }
        
        // Display comparison results
        function displayComparisonResults(results) {
            if (!results) {
                document.getElementById('framerate-comparison').textContent = 'Comparison failed.';
                return;
            }
            
            let comparisonText = 'Frame Rate Comparison:\n\n';
            
            // Count crossings for each frame rate
            const frameRates = Object.keys(results);
            
            comparisonText += 'Detected Crossings:\n';
            for (const fps of frameRates) {
                comparisonText += `- ${fps}fps: ${results[fps].length} crossings\n`;
            }
            
            comparisonText += '\nPrecision Analysis:\n';
            
            // Compare precision
            for (const fps of frameRates) {
                const frameResults = results[fps];
                if (frameResults.length > 0) {
                    const totalPrecision = frameResults.reduce((sum, r) => sum + Math.abs(r.subframePrecision), 0);
                    const avgPrecision = totalPrecision / frameResults.length;
                    
                    // Find min and max precision
                    const precisions = frameResults.map(r => Math.abs(r.subframePrecision));
                    const minPrecision = Math.min(...precisions);
                    const maxPrecision = Math.max(...precisions);
                    
                    comparisonText += `- ${fps}fps:\n`;
                    comparisonText += `  • Average Precision: ${avgPrecision.toFixed(3)}ms\n`;
                    comparisonText += `  • Min/Max: ${minPrecision.toFixed(3)}ms / ${maxPrecision.toFixed(3)}ms\n`;
                }
            }
            
            // Compare timing intervals
            comparisonText += '\nTiming Interval Analysis:\n';
            
            const intervalData = {};
            for (const fps of frameRates) {
                const frameResults = results[fps];
                if (frameResults.length > 1) {
                    const intervals = [];
                    for (let i = 1; i < frameResults.length; i++) {
                        intervals.push(frameResults[i].crossingTime - frameResults[i-1].crossingTime);
                    }
                    
                    const avgInterval = intervals.reduce((sum, i) => sum + i, 0) / intervals.length;
                    intervalData[fps] = avgInterval;
                    
                    comparisonText += `- ${fps}fps: ${avgInterval.toFixed(6)}s average interval\n`;
                }
            }
            
            // Calculate consistency
            if (Object.keys(intervalData).length > 1) {
                comparisonText += '\nConsistency Analysis:\n';
                
                const allIntervals = Object.values(intervalData);
                const avgOfAvgs = allIntervals.reduce((sum, i) => sum + i, 0) / allIntervals.length;
                const deviations = allIntervals.map(i => Math.abs(i - avgOfAvgs) / avgOfAvgs * 100);
                const maxDeviation = Math.max(...deviations);
                
                comparisonText += `- Max Deviation Between Frame Rates: ${maxDeviation.toFixed(2)}%\n`;
                comparisonText += `- Overall Consistency Rating: ${(100 - maxDeviation).toFixed(2)}%\n`;
            }
            
            document.getElementById('framerate-comparison').textContent = comparisonText;
        }
        
        // Visualize crossings
        function visualizeCrossings(results) {
            if (!results || results.length === 0) return;
            
            // Show crossing points
            results.forEach(result => {
                addCrossingMarker(
                    0, // Crossings always at x=0
                    result.position.y,
                    0.1,
                    result.crossingTime,
                    true
                );
            });
            
            // Show sampling points if enabled
            if (document.getElementById('show-path-sampling').checked) {
                // Fetch sampling points from the engine
                const engine = testInstance.engine;
                
                // Get vertex states if available
                if (engine.vertexStates && engine.vertexStates.has(testInstance.vertexId)) {
                    const states = engine.vertexStates.get(testInstance.vertexId);
                    
                    // Visualize each state point
                    states.forEach(state => {
                        addSamplingPoint(
                            state.position.x,
                            state.position.y,
                            0.05,
                            state.timestamp
                        );
                    });
                }
            }
        }
        
        // Run frame-rate independence test
        async function runFrameRateIndependenceTest() {
            // Clear previous results
            clearMarkers();
            
            // Update UI
            document.getElementById('framerate-independence').textContent = 'Running frame-rate independence test...';
            
            // Get engine configuration
            const microSteps = parseInt(document.getElementById('micro-steps').value);
            const resolution = parseInt(document.getElementById('resolution').value);
            const useHighPrecision = document.getElementById('high-precision').checked;
            const trackVelocity = document.getElementById('track-velocity').checked;
            
            // Create new test instance with configured parameters
            testInstance = new SubframePrecisionTest();
            testInstance.engine = new TemporalTriggerEngine({
                resolution,
                microSteps,
                useHighPrecision,
                trackVelocity,
                debugMode: true
            });
            
            // Run the test (asynchronously)
            await new Promise(resolve => setTimeout(resolve, 100));
            const results = testInstance.testRefactoredTriggerSystem();
            
            // Display independence results
            displayIndependenceResults(results);
        }
        
        // Display independence results
        function displayIndependenceResults(results) {
            if (!results) {
                document.getElementById('framerate-independence').textContent = 'Test failed.';
                return;
            }
            
            let resultText = 'Frame-Rate Independence Analysis:\n\n';
            
            // Display counts at each framerate
            resultText += 'Trigger counts at different frame rates:\n';
            for (const [fps, result] of Object.entries(results.framerateResults)) {
                resultText += `- ${fps}fps: ${result.originalCount} original triggers, ${result.temporalCount} temporal triggers\n`;
            }
            
            // Display standard deviations
            resultText += '\nStandard Deviation Analysis:\n';
            resultText += `- Original system: ${results.originalStdDev.toFixed(2)}\n`;
            resultText += `- Temporal system: ${results.temporalStdDev.toFixed(2)}\n`;
            resultText += '\nLower standard deviation indicates better frame-rate independence.\n';
            
            // Display timing differences between systems
            resultText += '\nTiming Analysis:\n';
            resultText += `- Average timing difference: ${results.stats.summary.averageTimingDifference}\n`;
            resultText += `- Match percentage: ${results.stats.summary.matchPercentage}\n`;
            resultText += `- Unmatched original: ${results.stats.summary.unmatchedOriginalPercentage}\n`;
            resultText += `- Unmatched temporal: ${results.stats.summary.unmatchedTemporalPercentage}\n`;
            
            // Calculate improvement percentage
            if (results.originalStdDev > 0 && results.temporalStdDev > 0) {
                const improvement = (1 - results.temporalStdDev / results.originalStdDev) * 100;
                resultText += `\nTemporal system is ${improvement.toFixed(1)}% more consistent across frame rates\n`;
            }
            
            document.getElementById('framerate-independence').textContent = resultText;
        }
        
        // Initialize page
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize visualization
            initVisualization();
            
            // Add event listeners
            document.getElementById('run-test').addEventListener('click', runTest);
            document.getElementById('run-comparison').addEventListener('click', runComparison);
            document.getElementById('run-independence-test').addEventListener('click', runFrameRateIndependenceTest);
        });
    </script>
</body>
</html> 