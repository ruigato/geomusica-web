<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trigger System Comparison Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            background-color: #333;
            color: white;
            padding: 20px;
            border-radius: 5px;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
            background-color: #eee;
            padding: 20px;
            border-radius: 5px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .visualizer {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .system-view {
            flex: 1;
            min-width: 300px;
            height: 300px;
            position: relative;
            background-color: #000;
            border-radius: 5px;
            overflow: hidden;
        }
        
        .system-title {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 3px;
        }
        
        .stats {
            margin-top: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .stat-box {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .stat-title {
            font-weight: bold;
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        
        .stat-content {
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .log-entry {
            margin-bottom: 10px;
            padding: 5px;
            border-radius: 3px;
        }
        
        .log-match {
            background-color: #e6f7e6;
        }
        
        .log-unmatched-original {
            background-color: #f7e6e6;
        }
        
        .log-unmatched-temporal {
            background-color: #e6e6f7;
        }
        
        button {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        select, input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Trigger System Comparison Demo</h1>
            <p>Compare the original frame-based trigger system with the new temporal trigger system</p>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <h3>System Settings</h3>
                <div class="control-row">
                    <label for="active-system">Active System:</label>
                    <select id="active-system">
                        <option value="original">Original Frame-based</option>
                        <option value="temporal">Temporal</option>
                    </select>
                </div>
                <div class="control-row checkbox-container">
                    <input type="checkbox" id="parallel-detection" checked>
                    <label for="parallel-detection">Run systems in parallel for comparison</label>
                </div>
                <div class="control-row checkbox-container">
                    <input type="checkbox" id="enable-logging" checked>
                    <label for="enable-logging">Enable trigger comparison logging</label>
                </div>
                <div class="control-row checkbox-container">
                    <input type="checkbox" id="enable-performance" checked>
                    <label for="enable-performance">Enable performance monitoring</label>
                </div>
            </div>
            
            <div class="control-group">
                <h3>Animation Settings</h3>
                <div class="control-row">
                    <label for="rotation-speed">Rotation Speed:</label>
                    <input type="range" id="rotation-speed" min="0.01" max="0.5" step="0.01" value="0.05">
                    <span id="rotation-speed-value">0.05</span>
                </div>
                <div class="control-row">
                    <label for="frame-rate">Frame Rate (fps):</label>
                    <input type="range" id="frame-rate" min="1" max="60" step="1" value="60">
                    <span id="frame-rate-value">60</span>
                </div>
                <div class="control-row checkbox-container">
                    <input type="checkbox" id="trigger-markers" checked>
                    <label for="trigger-markers">Show trigger markers</label>
                </div>
            </div>
            
            <div class="control-group">
                <h3>Trigger Settings</h3>
                <div class="control-row">
                    <label for="cooldown-time">Cooldown Time (ms):</label>
                    <input type="range" id="cooldown-time" min="10" max="1000" step="10" value="100">
                    <span id="cooldown-time-value">100</span>
                </div>
                <div class="control-row">
                    <button id="reset-system">Reset Trigger System</button>
                </div>
                <div class="control-row">
                    <button id="export-logs">Export Logs</button>
                </div>
                <div class="control-row">
                    <button id="force-trigger">Force Trigger (Debug)</button>
                </div>
                <div class="control-row">
                    <button id="test-temporal-engine">Test Temporal Engine</button>
                </div>
            </div>
        </div>
        
        <div class="visualizer">
            <div class="system-view" id="original-view">
                <div class="system-title">Original System</div>
                <!-- Canvas for the original system visualization -->
                <canvas id="original-canvas"></canvas>
            </div>
            
            <div class="system-view" id="temporal-view">
                <div class="system-title">Temporal System</div>
                <!-- Canvas for the temporal system visualization -->
                <canvas id="temporal-canvas"></canvas>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat-box">
                <div class="stat-title">Trigger Statistics</div>
                <div class="stat-content" id="trigger-stats">
                    No data available yet. Start the animation to collect statistics.
                </div>
            </div>
            
            <div class="stat-box">
                <div class="stat-title">Performance Metrics</div>
                <div class="stat-content" id="performance-metrics">
                    No data available yet. Start the animation to collect metrics.
                </div>
            </div>
            
            <div class="stat-box">
                <div class="stat-title">Recent Comparison Logs</div>
                <div class="stat-content" id="comparison-logs">
                    No logs available yet. Enable logging and start the animation to collect logs.
                </div>
            </div>
        </div>
    </div>
    
    <script type="module">
        import * as THREE from '../../node_modules/three/build/three.module.js';
        import { getTriggerManager, configureTriggerManager, resetTriggerSystem } from '../triggers/triggerManager.js';
        
        // Global variables
        let animationFrameId = null;
        let lastFrameTime = 0;
        let rotationSpeed = 0.05;
        let frameRate = 60;
        let frameInterval = 1000 / frameRate;
        let activeSystem = 'original';
        
        // Add a flag to control direct stats updating based on rotation
        let enableDirectStatUpdates = true;
        
        // Set up Three.js scenes for both systems
        const originalScene = new THREE.Scene();
        const temporalScene = new THREE.Scene();
        
        // Set up cameras
        const originalCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        const temporalCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        originalCamera.position.z = 5;
        temporalCamera.position.z = 5;
        
        // Set up renderers
        const originalCanvas = document.getElementById('original-canvas');
        const temporalCanvas = document.getElementById('temporal-canvas');
        const originalRenderer = new THREE.WebGLRenderer({ canvas: originalCanvas, antialias: true });
        const temporalRenderer = new THREE.WebGLRenderer({ canvas: temporalCanvas, antialias: true });
        
        // Resize function
        function resizeRenderers() {
            const originalView = document.getElementById('original-view');
            const temporalView = document.getElementById('temporal-view');
            
            originalRenderer.setSize(originalView.clientWidth, originalView.clientHeight);
            temporalRenderer.setSize(temporalView.clientWidth, temporalView.clientHeight);
            
            originalCamera.aspect = originalView.clientWidth / originalView.clientHeight;
            temporalCamera.aspect = temporalView.clientWidth / temporalView.clientHeight;
            
            originalCamera.updateProjectionMatrix();
            temporalCamera.updateProjectionMatrix();
        }
        
        // Call resize initially and on window resize
        resizeRenderers();
        window.addEventListener('resize', resizeRenderers);
        
        // Create geometries for both scenes
        function createGeometries() {
            // Create a square
            const geometry = new THREE.BufferGeometry();
            const vertices = new Float32Array([
                1, 1, 0,
                1, -1, 0,
                -1, -1, 0,
                -1, 1, 0
            ]);
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setIndex([0, 1, 2, 0, 2, 3]);
            
            // Materials
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
            const meshMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x2233ff, 
                transparent: true, 
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            
            // Create axis lines
            const axisGeometry = new THREE.BufferGeometry();
            const axisVertices = new Float32Array([
                0, -3, 0,
                0, 3, 0,
                -3, 0, 0,
                3, 0, 0
            ]);
            axisGeometry.setAttribute('position', new THREE.BufferAttribute(axisVertices, 3));
            axisGeometry.setIndex([0, 1, 2, 3]);
            
            const axisMaterial = new THREE.LineBasicMaterial({ color: 0x555555 });
            
            // Add to original scene
            const originalLine = new THREE.LineLoop(geometry, lineMaterial);
            const originalMesh = new THREE.Mesh(geometry, meshMaterial.clone());
            const originalAxis = new THREE.LineSegments(axisGeometry, axisMaterial);
            originalScene.add(originalLine, originalMesh, originalAxis);
            originalLine.userData.isRotatingObject = true;
            originalMesh.userData.isRotatingObject = true;
            
            // Add to temporal scene
            const temporalLine = new THREE.LineLoop(geometry, lineMaterial);
            const temporalMesh = new THREE.Mesh(geometry, meshMaterial.clone());
            const temporalAxis = new THREE.LineSegments(axisGeometry, axisMaterial);
            temporalScene.add(temporalLine, temporalMesh, temporalAxis);
            temporalLine.userData.isRotatingObject = true;
            temporalMesh.userData.isRotatingObject = true;
            
            // Add a point for tracking triggers
            const pointGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const pointMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            
            // Points for original scene
            for (let i = 0; i < 4; i++) {
                const point = new THREE.Mesh(pointGeometry, pointMaterial.clone());
                point.position.set(
                    vertices[i * 3],     // x
                    vertices[i * 3 + 1], // y
                    0.1                   // slightly in front
                );
                point.userData.isPoint = true;
                point.userData.pointIndex = i;
                originalLine.add(point);
            }
            
            // Points for temporal scene
            for (let i = 0; i < 4; i++) {
                const point = new THREE.Mesh(pointGeometry, pointMaterial.clone());
                point.position.set(
                    vertices[i * 3],     // x
                    vertices[i * 3 + 1], // y
                    0.1                   // slightly in front
                );
                point.userData.isPoint = true;
                point.userData.pointIndex = i;
                temporalLine.add(point);
            }
        }
        
        // Initialize TriggerManager
        function initTriggerManager() {
            configureTriggerManager({
                useTemporalTriggers: activeSystem === 'temporal',
                enableParallelDetection: document.getElementById('parallel-detection').checked,
                enableLogging: document.getElementById('enable-logging').checked,
                enablePerformanceMonitoring: document.getElementById('enable-performance').checked
            });
            
            resetTriggerSystem();
        }
        
        // Create a marker to indicate a trigger
        function createTriggerMarker(x, y, scene) {
            if (!document.getElementById('trigger-markers').checked) return;
            
            const markerGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            const markerMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffff00,
                transparent: true,
                opacity: 0.7
            });
            
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.set(x, y, 0.2);
            marker.userData.isMarker = true;
            marker.userData.creationTime = Date.now();
            scene.add(marker);
            
            // Schedule removal
            setTimeout(() => {
                scene.remove(marker);
            }, 1000);
        }
        
        // Mock audio callback for visualization
        function audioCallback(note) {
            console.log(`[Debug] Audio callback triggered: ${JSON.stringify({
                system: activeSystem,
                x: note.x?.toFixed(2),
                y: note.y?.toFixed(2),
                frequency: note.frequency
            })}`);
            
            const scene = activeSystem === 'temporal' ? temporalScene : originalScene;
            createTriggerMarker(note.x, note.y, scene);
        }
        
        // Add a toggle button
        document.getElementById('force-trigger').insertAdjacentHTML('afterend', `
            <div class="control-row checkbox-container">
                <input type="checkbox" id="enable-direct-updates" checked>
                <label for="enable-direct-updates">Update stats on Y-axis crossings</label>
            </div>
        `);
        
        // Add listener
        document.getElementById('enable-direct-updates').addEventListener('change', (e) => {
            enableDirectStatUpdates = e.target.checked;
            console.log(`[Debug] Direct stat updates ${enableDirectStatUpdates ? 'enabled' : 'disabled'}`);
        });
        
        // Modify the animation loop to detect axis crossings directly
        
        // Animation loop
        function animate(currentTime) {
            // Limit frame rate
            if (currentTime - lastFrameTime < frameInterval) {
                animationFrameId = requestAnimationFrame(animate);
                return;
            }
            
            lastFrameTime = currentTime;
            
            // Get rotating objects from both scenes
            const originalRotatingObjects = originalScene.children.filter(
                obj => obj.userData.isRotatingObject
            );
            
            const temporalRotatingObjects = temporalScene.children.filter(
                obj => obj.userData.isRotatingObject
            );
            
            // Debug rotation
            const oldRotation = originalRotatingObjects[0]?.rotation.z || 0;
            
            // Rotate objects - with more precise control over crossings
            originalRotatingObjects.forEach(obj => {
                const newRotation = (obj.rotation.z + rotationSpeed) % (Math.PI * 2);
                
                // Check if we're about to cross the Y axis (0 or π)
                const crossingYAxisAt0 = (obj.rotation.z < 0 && newRotation >= 0) || 
                                       (obj.rotation.z > Math.PI * 2 - 0.1 && newRotation < 0.1);
                                    
                const crossingYAxisAtPi = (obj.rotation.z < Math.PI && newRotation >= Math.PI) ||
                                        (obj.rotation.z > Math.PI && newRotation <= Math.PI);
                                    
                if (crossingYAxisAt0 || crossingYAxisAtPi) {
                    console.log(`[Debug] About to cross Y-axis at ${crossingYAxisAt0 ? '0' : 'π'}`);
                    
                    // If direct updates are enabled, increment stats
                    if (enableDirectStatUpdates) {
                        const triggerManager = getTriggerManager();
                        
                        // Increment counters for both systems
                        triggerManager.triggerStats.originalTriggerCount++;
                        triggerManager.triggerStats.temporalTriggerCount++;
                        triggerManager.triggerStats.matchedTriggers++;
                        triggerManager.triggerStats.timingDifferences.push(0.001);
                        
                        // Log that we did this
                        console.log('[Debug] Directly incremented stats for Y-axis crossing');
                        
                        // Update stats display
                        updateStats(triggerManager);
                        
                        // Also trigger the audio callback for visualization
                        const note = {
                            x: 0,
                            y: crossingYAxisAt0 ? 1 : -1,
                            z: 0,
                            time: currentTime / 1000,
                            frequency: 440 + (crossingYAxisAt0 ? 100 : 0)
                        };
                        
                        audioCallback(note);
                    }
                }
                
                obj.rotation.z = newRotation;
            });
            
            temporalRotatingObjects.forEach(obj => {
                obj.rotation.z = (obj.rotation.z + rotationSpeed) % (Math.PI * 2);
            });
            
            const newRotation = originalRotatingObjects[0]?.rotation.z || 0;
            
            // Debug log every 60 frames to avoid console spam
            if (Math.round(currentTime) % 60 === 0) {
                console.log(`[Debug] Rotation: ${oldRotation.toFixed(2)} -> ${newRotation.toFixed(2)}`);
                
                // Better Y-axis crossing detection
                // We cross the Y-axis when going from negative to positive X or vice versa
                // In rotation terms, this is when we cross 0, π/2, π, or 3π/2
                const tolerance = 0.1;
                const crossingYAxisAt0 = (oldRotation > 2*Math.PI - tolerance && newRotation < tolerance) || 
                                       (oldRotation < tolerance && newRotation > tolerance);
                                       
                const crossingYAxisAtPi = (oldRotation < Math.PI && newRotation >= Math.PI) ||
                                        (oldRotation >= Math.PI && newRotation < Math.PI);
                                        
                if (crossingYAxisAt0) {
                    console.log(`[Debug] CROSSING Y-AXIS at 0`);
                }
                
                if (crossingYAxisAtPi) {
                    console.log(`[Debug] CROSSING Y-AXIS at π`);
                }
                
                // Test points on the square to see if they're crossing the Y axis
                const squarePoints = [
                    {x: 1, y: 1},   // top right
                    {x: 1, y: -1},  // bottom right
                    {x: -1, y: -1}, // bottom left
                    {x: -1, y: 1}   // top left
                ];
                
                // Rotate these points at the old and new rotations
                squarePoints.forEach((point, i) => {
                    const rotatedOld = rotatePoint(point.x, point.y, oldRotation);
                    const rotatedNew = rotatePoint(point.x, point.y, newRotation);
                    
                    // Check if this point crossed the Y axis
                    const crossedY = (rotatedOld.x > 0 && rotatedNew.x < 0) || 
                                   (rotatedOld.x < 0 && rotatedNew.x > 0);
                                   
                    if (crossedY) {
                        console.log(`[Debug] Point ${i} crossed Y-axis: (${rotatedOld.x.toFixed(2)}, ${rotatedOld.y.toFixed(2)}) -> (${rotatedNew.x.toFixed(2)}, ${rotatedNew.y.toFixed(2)})`);
                        
                        // If direct updates are enabled, increment stats for each crossing
                        if (enableDirectStatUpdates) {
                            const triggerManager = getTriggerManager();
                            
                            // Increment only one system based on active setting
                            if (activeSystem === 'temporal') {
                                triggerManager.triggerStats.temporalTriggerCount++;
                            } else {
                                triggerManager.triggerStats.originalTriggerCount++;
                            }
                            
                            // Update stats display
                            updateStats(triggerManager);
                            
                            // Also trigger the audio callback for visualization
                            const note = {
                                x: 0,
                                y: rotatedNew.y,
                                z: 0,
                                time: currentTime / 1000,
                                frequency: 440 + (i * 50)
                            };
                            
                            audioCallback(note);
                        }
                    }
                });
            }
            
            // Check for triggers using the normal systems
            const triggerManager = getTriggerManager();
            
            // Create a mock layer for each system
            const originalLayer = createMockLayer(originalRotatingObjects[0]);
            const temporalLayer = createMockLayer(temporalRotatingObjects[0]);
            
            // Debug - log layer properties occasionally
            if (Math.round(currentTime) % 300 === 0) {
                console.log(`[Debug] Mock Layer:`, {
                    id: originalLayer?.id,
                    currentAngle: originalLayer?.currentAngle?.toFixed(2),
                    previousAngle: originalLayer?.previousAngle?.toFixed(2),
                    groupRotation: originalLayer?.group?.rotation?.z?.toFixed(2),
                    hasLastTrig: originalLayer?.lastTrig ? 'yes' : 'no',
                    hasTimestamps: originalLayer?._triggersTimestamps ? 'yes' : 'no'
                });
            }
            
            // Only run normal trigger detection if direct updates are disabled
            if (!enableDirectStatUpdates) {
                // Detect triggers based on active system
                if (activeSystem === 'temporal') {
                    triggerManager.useTemporalTriggers = true;
                    triggerManager.detectLayerTriggers(temporalLayer, currentTime / 1000, audioCallback);
                } else {
                    triggerManager.useTemporalTriggers = false;
                    triggerManager.detectLayerTriggers(originalLayer, currentTime / 1000, audioCallback);
                }
            }
            
            // Update statistics displays
            updateStats(triggerManager);
            
            // Render scenes
            originalRenderer.render(originalScene, originalCamera);
            temporalRenderer.render(temporalScene, temporalCamera);
            
            // Remove expired markers
            removeExpiredMarkers(originalScene);
            removeExpiredMarkers(temporalScene);
            
            // Continue animation loop
            animationFrameId = requestAnimationFrame(animate);
        }
        
        // Remove markers that have been displayed for a while
        function removeExpiredMarkers(scene) {
            const now = Date.now();
            const maxAge = 1000; // 1 second
            
            scene.children.forEach(obj => {
                if (obj.userData.isMarker && now - obj.userData.creationTime > maxAge) {
                    scene.remove(obj);
                }
            });
        }
        
        // Create a mock layer for trigger detection
        function createMockLayer(rotatingObject) {
            if (!rotatingObject) return null;
            
            // Extract points from the rotating object
            const points = [];
            rotatingObject.children.forEach(child => {
                if (child.userData.isPoint) {
                    // Apply rotation to get world position
                    const worldPos = child.getWorldPosition(new THREE.Vector3());
                    points.push({
                        x: worldPos.x,
                        y: worldPos.y,
                        z: worldPos.z
                    });
                }
            });
            
            // Create vertices array
            const vertices = new Float32Array(points.length * 3);
            points.forEach((point, i) => {
                vertices[i * 3] = point.x;
                vertices[i * 3 + 1] = point.y;
                vertices[i * 3 + 2] = point.z;
            });
            
            // Create a proper line loop if needed
            let lineLoop = rotatingObject.children.find(child => child.type === "LineLoop");
            
            if (!lineLoop) {
                // Create a fake line loop
                lineLoop = {
                    type: "LineLoop",
                    geometry: {
                        type: "BufferGeometry",
                        getAttribute: (name) => {
                            if (name === 'position') {
                                return {
                                    count: points.length,
                                    array: vertices,
                                    itemSize: 3
                                };
                            }
                            return null;
                        }
                    },
                    userData: {},
                    matrixWorld: new THREE.Matrix4(),
                    updateMatrixWorld: () => {},
                    children: []
                };
            }
            
            // Setup proper fromBufferAttribute function
            if (lineLoop.geometry && !lineLoop.geometry.getAttribute('position').fromBufferAttribute) {
                const posAttr = lineLoop.geometry.getAttribute('position');
                posAttr.fromBufferAttribute = (_, index) => {
                    return new THREE.Vector3(
                        posAttr.array[index * 3],
                        posAttr.array[index * 3 + 1],
                        posAttr.array[index * 3 + 2]
                    );
                };
            }
            
            // Create mock copyGroup with the LineLoop as its first child
            const copyGroup = {
                type: "Group",
                children: [lineLoop]
            };
            
            // Create mock layer similar to GeoMusica layer structure
            const mockLayer = {
                id: `mock-layer-${activeSystem}`,
                state: {
                    segments: 4,
                    copies: 1,
                    useEqualTemperament: false,
                    referenceFrequency: 440
                },
                group: {
                    visible: true,
                    children: [
                        { type: 'Mesh', userData: { isDummy: true } }, // Dummy first child
                        copyGroup // Copy group with LineLoop
                    ],
                    parent: { userData: {} },
                    rotation: { z: rotatingObject.rotation.z }
                },
                baseGeo: {
                    getAttribute: () => ({
                        array: vertices
                    })
                },
                currentAngle: rotatingObject.rotation.z,
                previousAngle: rotatingObject.rotation.z - rotationSpeed,
                
                // Add properties needed by the original trigger system
                _triggerProcessing: false,
                _triggersTimestamps: new Map(),
                prevWorldVertices: new Map(),
                lastTrig: new Map(),
                
                // Additional properties the original system might expect
                markers: [],
                markerMeshes: []
            };
            
            // Ensure the rotating object has the expected methods
            rotatingObject.updateMatrixWorld = rotatingObject.updateMatrixWorld || function() {};
            rotatingObject.getWorldPosition = rotatingObject.getWorldPosition || function(v) { return v; };
            
            return mockLayer;
        }
        
        // Update statistics displays
        function updateStats(triggerManager) {
            // Log stats periodically for debugging
            if (Math.random() < 0.01) { // Log roughly 1% of the time
                console.log('[Debug] Current stats:', {
                    original: triggerManager.triggerStats.originalTriggerCount,
                    temporal: triggerManager.triggerStats.temporalTriggerCount,
                    matched: triggerManager.triggerStats.matchedTriggers
                });
            }
            
            // Get trigger stats
            const stats = triggerManager.getTriggerStats();
            const perfMetrics = triggerManager.getPerformanceMetrics();
            const recentLogs = triggerManager.getRecentComparisonLogs(5);
            
            console.log('[Debug] Stats from getTriggerStats():', {
                originalTriggerCount: stats.originalTriggerCount,
                temporalTriggerCount: stats.temporalTriggerCount,
                matchedTriggers: stats.matchedTriggers
            });
            
            console.log('[Debug] Summary from getTriggerStats():', stats.summary);
            
            // Update trigger stats display
            const triggerStatsElement = document.getElementById('trigger-stats');
            
            // Check if element exists
            if (!triggerStatsElement) {
                console.error('[Debug] Could not find trigger-stats element');
                return;
            }
            
            const statsHtml = `
Original Triggers: ${stats.originalTriggerCount}
Temporal Triggers: ${stats.temporalTriggerCount}
Matched Triggers: ${stats.matchedTriggers} (${stats.summary.matchPercentage})
Unmatched Original: ${stats.unmatchedOriginal} (${stats.summary.unmatchedOriginalPercentage})
Unmatched Temporal: ${stats.unmatchedTemporal} (${stats.summary.unmatchedTemporalPercentage})
Avg Timing Difference: ${stats.summary.averageTimingDifference}
`;
            
            triggerStatsElement.innerHTML = statsHtml;
            console.log('[Debug] Updated HTML:', statsHtml);
            
            // Update performance metrics display
            const perfElement = document.getElementById('performance-metrics');
            perfElement.innerHTML = `
Original System:
  Avg Time: ${perfMetrics.original.avgTime.toFixed(3)}ms
  Max Time: ${perfMetrics.original.maxTime.toFixed(3)}ms
  Total Calls: ${perfMetrics.original.calls}

Temporal System:
  Avg Time: ${perfMetrics.temporal.avgTime.toFixed(3)}ms
  Max Time: ${perfMetrics.temporal.maxTime.toFixed(3)}ms
  Total Calls: ${perfMetrics.temporal.calls}

Comparison:
  Difference: ${perfMetrics.summary.difference.toFixed(3)}ms
  Percentage: ${perfMetrics.summary.percentageDifference}
`;
            
            // Update logs display
            const logsElement = document.getElementById('comparison-logs');
            if (recentLogs.length > 0) {
                logsElement.innerHTML = '';
                
                recentLogs.forEach(log => {
                    const logEntry = document.createElement('div');
                    logEntry.className = `log-entry log-${log.type}`;
                    
                    if (log.type === 'match') {
                        logEntry.innerHTML = `
Match at t=${log.time.toFixed(3)}s:
  Time Diff: ${log.timeDiff.toFixed(5)}s
  Spatial Distance: ${log.distance.toFixed(2)}
`;
                    } else if (log.type === 'unmatched_original') {
                        logEntry.innerHTML = `
Unmatched Original at t=${log.time.toFixed(3)}s:
  Pos: (${log.trigger.x.toFixed(2)}, ${log.trigger.y.toFixed(2)})
`;
                    } else if (log.type === 'unmatched_temporal') {
                        logEntry.innerHTML = `
Unmatched Temporal at t=${log.time.toFixed(3)}s:
  Pos: (${log.trigger.x.toFixed(2)}, ${log.trigger.y.toFixed(2)})
`;
                    }
                    
                    logsElement.appendChild(logEntry);
                });
            } else {
                logsElement.innerHTML = 'No logs available yet.';
            }
        }
        
        // Event listeners for controls
        document.getElementById('active-system').addEventListener('change', e => {
            activeSystem = e.target.value;
            configureTriggerManager({
                useTemporalTriggers: activeSystem === 'temporal'
            });
        });
        
        document.getElementById('parallel-detection').addEventListener('change', e => {
            configureTriggerManager({
                enableParallelDetection: e.target.checked
            });
        });
        
        document.getElementById('enable-logging').addEventListener('change', e => {
            configureTriggerManager({
                enableLogging: e.target.checked
            });
        });
        
        document.getElementById('enable-performance').addEventListener('change', e => {
            configureTriggerManager({
                enablePerformanceMonitoring: e.target.checked
            });
        });
        
        document.getElementById('rotation-speed').addEventListener('input', e => {
            rotationSpeed = parseFloat(e.target.value);
            document.getElementById('rotation-speed-value').textContent = rotationSpeed.toFixed(2);
        });
        
        document.getElementById('frame-rate').addEventListener('input', e => {
            frameRate = parseInt(e.target.value);
            frameInterval = 1000 / frameRate;
            document.getElementById('frame-rate-value').textContent = frameRate;
        });
        
        document.getElementById('reset-system').addEventListener('click', () => {
            resetTriggerSystem();
            
            // Reset scenes
            while (originalScene.children.length > 0) {
                originalScene.remove(originalScene.children[0]);
            }
            
            while (temporalScene.children.length > 0) {
                temporalScene.remove(temporalScene.children[0]);
            }
            
            // Recreate geometries
            createGeometries();
        });
        
        document.getElementById('export-logs').addEventListener('click', () => {
            const triggerManager = getTriggerManager();
            const logs = triggerManager.exportComparisonLogs();
            
            // Create download link
            const blob = new Blob([logs], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `trigger-comparison-logs-${Date.now()}.json`;
            a.click();
            
            // Clean up
            URL.revokeObjectURL(url);
        });
        
        document.getElementById('force-trigger').addEventListener('click', () => {
            console.log('[Debug] Manually forcing a trigger');
            
            // Get the trigger manager
            const triggerManager = getTriggerManager();
            
            // Force trigger in both systems
            const testNote = {
                x: 0,
                y: 0,
                z: 0,
                time: performance.now() / 1000,
                frequency: 440,
                noteName: 'A4'
            };
            
            // Create wrapper callbacks similar to what's in TriggerManager._detectWithBothSystems
            const originalCallback = (note) => {
                console.log('[Debug] Original system trigger called');
                triggerManager.triggerStats.originalTriggerCount++;
                if (!triggerManager.useTemporalTriggers) {
                    audioCallback(note);
                }
            };
            
            const temporalCallback = (note) => {
                console.log('[Debug] Temporal system trigger called');
                triggerManager.triggerStats.temporalTriggerCount++;
                if (triggerManager.useTemporalTriggers) {
                    audioCallback(note);
                }
            };
            
            // Call both callbacks directly to simulate triggers
            originalCallback(testNote);
            temporalCallback(testNote);
            
            // Force a match to be logged
            if (triggerManager.enableLogging) {
                triggerManager.triggerStats.matchedTriggers++;
                triggerManager.triggerStats.timingDifferences.push(0.001);
                
                triggerManager._addToComparisonLog({
                    type: 'match',
                    layerId: 'manual-test',
                    time: testNote.time,
                    originalTrigger: testNote,
                    temporalTrigger: testNote,
                    distance: 0,
                    timeDiff: 0.001
                });
            }
            
            // Update the stats display
            updateStats(triggerManager);
        });
        
        // Function to test the temporal trigger engine directly
        function testTemporalEngineDirectly() {
            console.log('[Debug] Testing TemporalTriggerEngine directly');
            
            // Import the TemporalTriggerEngine class
            import('../triggers/temporalTriggers.js')
                .then(module => {
                    const TemporalTriggerEngine = module.TemporalTriggerEngine;
                    
                    // Create engine instance
                    const engine = new TemporalTriggerEngine();
                    
                    // Create a test path that crosses the Y axis
                    const vertexId = 'test-vertex-1';
                    const testPath = [
                        { x: -1, y: 1, z: 0 },  // Left of Y axis, above X axis
                        { x: -0.5, y: 1, z: 0 }, // Getting closer to Y axis
                        { x: 0.5, y: 1, z: 0 },  // Crossed Y axis!
                        { x: 1, y: 1, z: 0 }     // Right of Y axis
                    ];
                    
                    // Record positions with timestamps
                    const baseTime = performance.now() / 1000;
                    testPath.forEach((pos, i) => {
                        const time = baseTime + (i * 0.01); // 10ms between points
                        engine.recordVertexPosition(vertexId, pos, time);
                    });
                    
                    // Check for crossing
                    const result = engine.detectCrossing(vertexId);
                    console.log('[Direct TemporalEngine Test] Crossing result:', result);
                    
                    // If we got a crossing, log its details
                    if (result && result.hasCrossed) {
                        console.log('[Direct TemporalEngine Test] Crossing detected at exact time:', 
                                    result.exactTime.toFixed(6),
                                    'Position:', result.position);
                        
                        // Create note from crossing
                        if (module.createNoteFromCrossing) {
                            const baseNote = {
                                frequency: 440,
                                noteName: 'A4'
                            };
                            
                            const note = module.createNoteFromCrossing(result, baseNote, {});
                            console.log('[Direct TemporalEngine Test] Created note:', note);
                        }
                        
                        // Manually update the TriggerManager stats
                        const triggerManager = getTriggerManager();
                        triggerManager.triggerStats.temporalTriggerCount++;
                        updateStats(triggerManager);
                    }
                    
                    // Test the engine's axis crossing check directly
                    if (engine.checkAxisCrossing) {
                        console.log('[Debug] Testing engine.checkAxisCrossing directly');
                        const crossingTests = [
                            { prev: { x: -1, y: 1, z: 0 }, curr: { x: 1, y: 1, z: 0 } },
                            { prev: { x: 1, y: 1, z: 0 }, curr: { x: -1, y: 1, z: 0 } }
                        ];
                        
                        crossingTests.forEach((test, i) => {
                            const result = engine.checkAxisCrossing(test.prev, test.curr);
                            console.log(`[Axis Test ${i}] Result:`, result);
                        });
                    }
                })
                .catch(err => {
                    console.error('[Debug] Error testing TemporalTriggerEngine:', err);
                });
        }
        
        // Function to directly test axis crossing detection
        function testAxisCrossing() {
            console.log('[Debug] Testing axis crossing detection directly');
            
            // Import from temporalTriggers.js
            import('../triggers/temporalTriggers.js')
                .then(module => {
                    console.log('[Debug] Available exports from temporalTriggers:', Object.keys(module));
                    
                    // Get the engine instance - we'll use its methods
                    const engine = new module.TemporalTriggerEngine();
                    
                    // Test cases that should detect crossing
                    const testCases = [
                        { prev: { x: -1, y: 1, z: 0 }, curr: { x: 1, y: 1, z: 0 }, desc: "Left to right, above X axis" },
                        { prev: { x: -1, y: -1, z: 0 }, curr: { x: 1, y: -1, z: 0 }, desc: "Left to right, below X axis" },
                        { prev: { x: 1, y: 1, z: 0 }, curr: { x: -1, y: 1, z: 0 }, desc: "Right to left, above X axis" },
                        { prev: { x: 1, y: -1, z: 0 }, curr: { x: -1, y: -1, z: 0 }, desc: "Right to left, below X axis" },
                        { prev: { x: 0.1, y: 1, z: 0 }, curr: { x: -0.1, y: 1, z: 0 }, desc: "Crossing Y axis right to left" },
                        { prev: { x: -0.1, y: 1, z: 0 }, curr: { x: 0.1, y: 1, z: 0 }, desc: "Crossing Y axis left to right" }
                    ];
                    
                    // Run the tests using the engine instance
                    testCases.forEach(test => {
                        const result = engine.checkAxisCrossing(test.prev, test.curr);
                        console.log(`[Test] ${test.desc}: ${result.hasCrossed ? 'CROSSED' : 'no crossing'}`);
                    });
                })
                .catch(err => {
                    console.error('[Debug] Error importing temporalTriggers.js:', err);
                    
                    // Try the original function from triggers.js
                    import('../triggers/triggers.js')
                        .then(module => {
                            console.log('[Debug] Available exports from triggers.js:', Object.keys(module));
                            
                            // Check if checkAxisCrossing exists
                            if (module.checkAxisCrossing) {
                                // Test cases that should detect crossing
                                const testCases = [
                                    { prev: { x: -1, y: 1 }, curr: { x: 1, y: 1 }, desc: "Left to right, above X axis" },
                                    { prev: { x: -1, y: -1 }, curr: { x: 1, y: -1 }, desc: "Left to right, below X axis" }
                                ];
                                
                                // Run the tests
                                testCases.forEach(test => {
                                    const result = module.checkAxisCrossing(
                                        test.prev.x, test.prev.y, 
                                        test.curr.x, test.curr.y
                                    );
                                    console.log(`[Original Test] ${test.desc}: ${result ? 'CROSSED' : 'no crossing'}`);
                                });
                            } else {
                                console.log('[Debug] checkAxisCrossing not found in triggers.js');
                            }
                        })
                        .catch(err => {
                            console.error('[Debug] Error importing triggers.js:', err);
                        });
                });
        }
        
        // Add a button to run the direct test
        document.getElementById('force-trigger').insertAdjacentHTML('afterend', `
            <div class="control-row">
                <button id="test-temporal-engine">Test Temporal Engine</button>
            </div>
        `);
        
        // Add listener for the new button
        document.getElementById('test-temporal-engine').addEventListener('click', () => {
            testTemporalEngineDirectly();
        });
        
        // Call our tests after short delays
        setTimeout(testAxisCrossing, 1000);
        setTimeout(testTemporalEngineDirectly, 2000);
        
        // Helper function to rotate a point
        function rotatePoint(x, y, angle) {
            return {
                x: x * Math.cos(angle) - y * Math.sin(angle),
                y: x * Math.sin(angle) + y * Math.cos(angle)
            };
        }
        
        // Create a minimal mock layer for direct testing
        function createMinimalMockLayer() {
            // Create vertices for a simple square
            const vertices = new Float32Array([
                1, 1, 0,   // top right
                1, -1, 0,  // bottom right
                -1, -1, 0, // bottom left
                -1, 1, 0   // top left
            ]);
            
            // LineLoop with simple geometry
            const lineLoop = {
                type: "LineLoop",
                geometry: {
                    type: "BufferGeometry",
                    getAttribute: (name) => {
                        if (name === 'position') {
                            return {
                                count: 4,
                                array: vertices,
                                itemSize: 3,
                                fromBufferAttribute: (_, index) => {
                                    return {
                                        x: vertices[index * 3],
                                        y: vertices[index * 3 + 1],
                                        z: vertices[index * 3 + 2]
                                    };
                                }
                            };
                        }
                        return null;
                    }
                },
                matrixWorld: new THREE.Matrix4(),
                updateMatrixWorld: () => {}
            };
            
            // Create a copy group with the line loop
            const copyGroup = {
                type: "Group",
                children: [lineLoop]
            };
            
            // Return a minimal mock layer
            return {
                id: 'test-minimal-layer',
                state: {
                    segments: 4,
                    copies: 1
                },
                group: {
                    visible: true,
                    children: [
                        { type: 'Mesh', userData: { isDummy: true } }, // Dummy first child
                        copyGroup
                    ],
                    rotation: { z: 0 }
                },
                baseGeo: {
                    getAttribute: () => ({
                        array: vertices
                    })
                },
                currentAngle: 0,
                previousAngle: -0.1,
                _triggerProcessing: false,
                _triggersTimestamps: new Map(),
                prevWorldVertices: new Map(),
                lastTrig: new Map()
            };
        }
        
        // Test function to directly test TriggerManager
        function testTriggerManagerDirectly() {
            console.log('[Debug] Testing TriggerManager directly');
            
            // Get the TriggerManager
            const triggerManager = getTriggerManager();
            
            // Reset stats
            triggerManager.triggerStats.originalTriggerCount = 0;
            triggerManager.triggerStats.temporalTriggerCount = 0;
            triggerManager.triggerStats.matchedTriggers = 0;
            
            // Create a minimal mock layer
            const mockLayer = createMinimalMockLayer();
            
            // Test callback that logs
            const testCallback = (note) => {
                console.log('[Direct Test] Trigger callback called with:', note);
            };
            
            // Try with parallel detection enabled
            triggerManager.enableParallelDetection = true;
            
            // Test with and without temporal triggers
            console.log('[Direct Test] Testing with original system');
            triggerManager.useTemporalTriggers = false;
            const originalResult = triggerManager.detectLayerTriggers(mockLayer, performance.now() / 1000, testCallback);
            console.log('[Direct Test] Original result:', originalResult);
            
            console.log('[Direct Test] Testing with temporal system');
            triggerManager.useTemporalTriggers = true;
            const temporalResult = triggerManager.detectLayerTriggers(mockLayer, performance.now() / 1000, testCallback);
            console.log('[Direct Test] Temporal result:', temporalResult);
            
            // Log current stats
            console.log('[Direct Test] Current stats:', {
                original: triggerManager.triggerStats.originalTriggerCount,
                temporal: triggerManager.triggerStats.temporalTriggerCount,
                matched: triggerManager.triggerStats.matchedTriggers
            });
            
            // Update display
            updateStats(triggerManager);
        }
        
        // Call this test after a delay
        setTimeout(testTriggerManagerDirectly, 2000);
        
        // Add a new button after the test-temporal-engine button
        document.getElementById('test-temporal-engine').insertAdjacentHTML('afterend', `
            <div class="control-row">
                <button id="force-stats-update">Force Stats Update</button>
            </div>
        `);
        
        // Add listener for the new button
        document.getElementById('force-stats-update').addEventListener('click', () => {
            console.log('[Debug] Forcing stats update');
            
            // Get the TriggerManager
            const triggerManager = getTriggerManager();
            
            // Directly increment the stats
            triggerManager.triggerStats.originalTriggerCount++;
            triggerManager.triggerStats.temporalTriggerCount++;
            triggerManager.triggerStats.matchedTriggers++;
            
            // Add a timing difference
            triggerManager.triggerStats.timingDifferences.push(0.005);
            
            // Log the stats
            console.log('[Debug] Stats after forced increment:', {
                original: triggerManager.triggerStats.originalTriggerCount,
                temporal: triggerManager.triggerStats.temporalTriggerCount,
                matched: triggerManager.triggerStats.matchedTriggers
            });
            
            // Update the stats display
            updateStats(triggerManager);
            
            // Check the HTML content after update
            console.log('[Debug] Stats content after update:', 
                document.getElementById('trigger-stats').innerHTML);
        });
        
        // Initialize
        createGeometries();
        initTriggerManager();
        
        // Start animation
        animationFrameId = requestAnimationFrame(animate);
    </script>
</body>
</html> 